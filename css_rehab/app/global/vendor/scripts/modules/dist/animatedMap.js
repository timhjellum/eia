define("animatedMap",["map"],function(Map){return Map.$extend({__init__:function(container){this.$super(container);var self=this;this.animation={enabled:!1,stepSize:1e3,iteration:0,interval:null}},update:function(counts,title,options){$.extend(this.animation,options.animation,{maxIteration:counts.length}),this.$super(counts,title,options)},play:function(loop,stepSize,callback){var self=this,animate=function(){var iteration;loop?iteration=self.animation.iteration%self.animation.maxIteration:(iteration=Math.min(self.animation.iteration,self.animation.maxIteration),iteration==self.animation.maxIteration&&self.stop()),$(".map_inside_container",self.mapContainer).vectorMap("set","colors",self.colors[iteration]),callback.call(self,iteration),self.animation.iteration=iteration+1};this.animation.interval&&this.stop(),animate(),this.animation.interval=setInterval(animate,stepSize||self.animation.stepSize)},stop:function(){clearInterval(this.animation.interval),this.animation.interval=null},reset:function(iteration){this.animation.iteration=Math.min(iteration,this.animation.maxIteration)},destroy:function(){this.$super()},getInitialColors:function(){return this.colors[this.animation.iteration]},calculateMinMax:function(counts){var ret={};for(var i=0;i<counts.length;i++)for(state in counts[i])counts[i].hasOwnProperty(state)&&(ret.min=ret.min==null||counts[i][state]<ret.min?counts[i][state]:ret.min,ret.max=ret.max==null||counts[i][state]>ret.max?counts[i][state]:ret.max);return ret},assignColors:function(counts,buckets,palette){var ret=[];for(var i=0;i<this.counts.length;i++)ret[i]=this.$super(this.counts[i],this.buckets,palette);return ret}})})